"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Injectable = function () {

  /**
   * Inject the injectable dependencies into the new instance and call the
   * initialization method.
   * @constructor
   */

  function Injectable() {
    _classCallCheck(this, Injectable);

    this.registerDependencies.apply(this, arguments);

    // Pass the injector to the init function.
    this.init(this.inject.bind(this));
  }

  Injectable.prototype.init = function init() {
    // To be implemented in sub-class.
  };

  Injectable.prototype.registerDependencies = function registerDependencies() {
    var _this = this,
        _arguments = arguments;

    this.constructor.dependencies.forEach(function (name, i) {
      _this.constructor.$deps[name] = _arguments[i];
    });
  };

  /**
   * Dependency injector helper function.
   */


  Injectable.prototype.inject = function inject(depName) {
    var dependency = this.constructor.$deps[depName];

    if (dependency === null || dependency === undefined) {
      var clsName = this.constructor.name;
      var type = this.constructor.$type;
      var errorMsg = "\"" + clsName + "\" got undefined when trying to inject " + ("\"" + depName + "\". Please make sure that it is declared in the ") + (type + " dependencies.");

      throw new Error(errorMsg);
    }

    return dependency;
  };

  return Injectable;
}();

Injectable.$deps = {};
Injectable.dependencies = [];
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Base class for Angular.js controllers.
 */

var Controller = function (_Injectable) {
  _inherits(Controller, _Injectable);

  function Controller() {
    _classCallCheck(this, Controller);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _possibleConstructorReturn(this, _Injectable.call.apply(_Injectable, [this].concat(args)));
  }

  /**
   * Register the given controller in the corresponding angular module.
   * @method
   *
   * @param {Class} ctrl    The controller class.
   */


  Controller.register = function register(ctrl) {
    var injectedCtrl = ctrl.dependencies.slice(0).concat([ctrl]);

    angular.module(ctrl.module).controller(ctrl.name, injectedCtrl);
  };

  return Controller;
}(Injectable);

Controller.$type = 'controller';
Controller.module = '';
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Directive = function (_Injectable) {
  _inherits(Directive, _Injectable);

  function Directive() {
    _classCallCheck(this, Directive);

    return _possibleConstructorReturn(this, _Injectable.apply(this, arguments));
  }

  Directive.register = function register(directive) {
    var injected = directive.dependencies.slice(0);

    injected.push(function () {
      var instance = Object.create(directive.prototype);
      directive.apply(instance, arguments);

      return instance;
    });

    angular.module(directive.module).directive(directive.name, injected);
  };

  return Directive;
}(Injectable);

Directive.$type = 'directive';
Directive.module = '';
Directive.dependencies = [];
Directive.Element = 'E';
Directive.Attribute = 'A';
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Component = function (_Injectable) {
  _inherits(Component, _Injectable);

  function Component() {
    _classCallCheck(this, Component);

    return _possibleConstructorReturn(this, _Injectable.apply(this, arguments));
  }

  Component.register = function register(component) {
    var name = component.name[0].toLowerCase() + component.slice(1);
    var injected = function injected() {
      var instance = Object.create(component.prototype);
      component.apply(instance, arguments);

      return instance;
    };

    injected.$inject = component.dependencies;
    component.restrict = Directive.Element;
    component.scope = component.bindings;

    angular.module(directive.module).directive(name, injected);
  };

  return Component;
}(Injectable);

Component.$type = 'component';
Component.module = '';
Component.dependencies = [];
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Service = function (_Injectable) {
  _inherits(Service, _Injectable);

  function Service() {
    _classCallCheck(this, Service);

    return _possibleConstructorReturn(this, _Injectable.apply(this, arguments));
  }

  /**
   * Register the given service in the corresponding angular module.
   * @method
   *
   * @param {Class} service   The service class.
   */

  Service.register = function register(service) {
    var injectedService = service.dependencies.slice(0).concat([service]);

    angular.module(service.module).service(service.name, injectedService);
  };

  return Service;
}(Injectable);

Service.$type = 'service';
Service.module = '';
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Factory = function (_Injectable) {
  _inherits(Factory, _Injectable);

  function Factory() {
    _classCallCheck(this, Factory);

    return _possibleConstructorReturn(this, _Injectable.apply(this, arguments));
  }

  /**
   * Register the given factory in the corresponding angular module.
   * @method
   *
   * @param {Class} factory   The factory class.
   */

  Factory.register = function register(factory) {
    var injectedFactory = factory.dependencies.slice(0).concat([factory]);

    angular.module(factory.module).factory(factory.name, injectedFactory);
  };

  return Factory;
}(Injectable);

Factory.$type = 'factory';
Factory.module = '';
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  Base class for angular modules.
 */

var Module = function () {
  function Module() {
    _classCallCheck(this, Module);
  }

  /**
   * Module configuration method.
   */

  Module.config = function config() {} /* Implement in subclass. */

  /**
   * Module initializer method.
   */
  ;

  Module.run = function run() {} /* Implement in subclass. */

  /**
   * Register this module instance in the angular module registry.
   */
  ;

  Module.register = function register(module) {
    var injectedConfig = module.configDependencies.slice(0);
    var injectedRun = module.runDependencies.slice(0);

    injectedConfig.push(module.config);
    injectedRun.push(module.run);

    angular.module(module.moduleName, module.dependencies).config(injectedConfig).run(injectedRun);
  };

  return Module;
}();

Module.dependencies = [];
Module.configDependencies = [];
Module.runDependencies = [];
Module.moduleName = '';
Module.$type = 'module';
'use strict';

/**
 * Hack in support for Function.name for browsers that don't support it.
 * IE, I'm looking at you.
**/
if (Function.prototype.name === undefined && Object.defineProperty !== undefined) {
  Object.defineProperty(Function.prototype, 'name', {
    get: function get() {
      var funcNameRegex = /function\s([^(]{1,})\(/;
      var results = funcNameRegex.exec(this.toString());
      return results && results.length > 1 ? results[1].trim() : "";
    },
    set: function set(value) {}
  });
}

window.$ng = {
  Directive: Directive,
  Controller: Controller,
  Component: Component,
  Module: Module,
  Service: Service,
  Factory: Factory,
  Bindings: {
    Reference: '=',
    Value: '@',
    Delayed: '&'
  },

  /**
   * Register the given class in its corresponding module.
   * @method
   *
   * @param {Class} cls   An instance of injectable.
   */
  register: function register(cls) {
    var type = cls.$type;
    var noModule = !cls.module || !cls.module.trim();

    // If this is not a Module class and has no module defined,
    // raise an error.
    if (type !== 'module' && noModule) {
      var name = cls.name;

      throw new Error('Module not defined for ' + type + ' "' + name + '"');
    }

    cls.register(cls);
  },

  /**
   * Traverses the DOM and counts the number of watchers.
   */
  wcount: function wcount() {
    var root = angular.element(document.getElementsByTagName('body'));
    var watchers = [];
    var watchersWithoutDuplicates = [];

    var f = function f(element) {
      angular.forEach(['$scope', '$isolateScope'], function (scopeProperty) {
        if (element.data() && element.data().hasOwnProperty(scopeProperty)) {
          // Append all the element watchers to the watchers array.
          angular.forEach(element.data()[scopeProperty].$$watchers, function (watcher) {
            return watchers.push(watcher);
          });
        }
      });

      // Process the children elements.
      angular.forEach(element.children(), function (childElement) {
        return f(angular.element(childElement));
      });
    };

    f(root);

    // Remove duplicate watchers.
    angular.forEach(watchers, function (item) {
      // Only add watchers that are not already present in the array.
      if (watchersWithoutDuplicates.indexOf(item) < 0) {
        watchersWithoutDuplicates.push(item);
      }
    });

    console.log('Watchers count:', watchersWithoutDuplicates.length);
  }
};