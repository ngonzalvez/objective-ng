"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Injectable = function () {

  /**
   * Inject the injectable dependencies into the new instance and call the
   * initialization method.
   * @constructor
   */

  function Injectable() {
    _classCallCheck(this, Injectable);

    this.registerDependencies.apply(this, arguments);

    // Pass the injector to the init function.
    this.init(this.inject.bind(this));
  }

  _createClass(Injectable, [{
    key: "init",
    value: function init() {
      // To be implemented in sub-class.
    }
  }, {
    key: "registerDependencies",
    value: function registerDependencies() {
      var _this = this,
          _arguments = arguments;

      this.constructor.dependencies.forEach(function (name, i) {
        _this.constructor.$deps[name] = _arguments[i];
      });
    }

    /**
     * Dependency injector helper function.
     */

  }, {
    key: "inject",
    value: function inject(depName) {
      var dependency = this.constructor.$deps[depName];
      // $ng.debug(`${ctrlName}: Injecting ${depName}`);

      if (dependency === null || dependency === undefined) {
        var clsName = this.constructor.name;
        var type = this.constructor.$type;
        var errorMsg = "\"" + clsName + "\" got undefined when trying to inject " + ("\"" + depName + "\". Please make sure that it is declared in the ") + (type + " dependencies.");

        throw new Error(errorMsg);
      }

      return dependency;
    }
  }]);

  return Injectable;
}();

Injectable.$deps = {};
Injectable.dependencies = [];
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Base class for Angular.js controllers.
 */

var Controller = function (_Injectable) {
  _inherits(Controller, _Injectable);

  function Controller() {
    _classCallCheck(this, Controller);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Controller).apply(this, arguments));
  }

  _createClass(Controller, null, [{
    key: 'register',

    /**
     * Register the given controller in the corresponding angular module.
     * @method
     *
     * @param {Class} ctrl    The controller class.
     */
    value: function register(ctrl) {
      var injectedCtrl = ctrl.dependencies.slice(0).concat([ctrl]);

      angular.module(ctrl.module).controller(ctrl.name, injectedCtrl);
    }
  }]);

  return Controller;
}(Injectable);

Controller.$type = 'controller';
Controller.module = '';
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Directive = function (_Injectable) {
  _inherits(Directive, _Injectable);

  function Directive() {
    _classCallCheck(this, Directive);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Directive).apply(this, arguments));
  }

  _createClass(Directive, null, [{
    key: 'register',
    value: function register(directive) {
      var injected = directive.dependencies.slice(0);

      injected.push(function () {
        var instance = Object.create(directive.prototype);
        directive.apply(instance, arguments);

        return instance;
      });

      angular.module(directive.module).directive(directive.tagName, injected);
    }
  }]);

  return Directive;
}(Injectable);

Directive.$type = 'directive';
Directive.module = '';
Directive.dependencies = [];
Directive.tagName = '';
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Service = function (_Injectable) {
  _inherits(Service, _Injectable);

  function Service() {
    _classCallCheck(this, Service);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Service).apply(this, arguments));
  }

  _createClass(Service, null, [{
    key: 'register',

    /**
     * Register the given service in the corresponding angular module.
     * @method
     *
     * @param {Class} service   The service class.
     */
    value: function register(service) {
      var injectedService = service.dependencies.slice(0).concat([service]);

      angular.module(service.module).service(service.name, injectedService);
    }
  }]);

  return Service;
}(Injectable);

Service.$type = 'service';
Service.module = '';
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Factory = function (_Injectable) {
  _inherits(Factory, _Injectable);

  function Factory() {
    _classCallCheck(this, Factory);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Factory).apply(this, arguments));
  }

  _createClass(Factory, null, [{
    key: 'register',

    /**
     * Register the given factory in the corresponding angular module.
     * @method
     *
     * @param {Class} factory   The factory class.
     */
    value: function register(factory) {
      var injectedFactory = factory.dependencies.slice(0).concat([factory]);

      angular.module(factory.module).factory(factory.name, injectedFactory);
    }
  }]);

  return Factory;
}(Injectable);

Factory.$type = 'factory';
Factory.module = '';
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  Base class for angular modules.
 */

var Module = function () {
  function Module() {
    _classCallCheck(this, Module);
  }

  _createClass(Module, null, [{
    key: 'config',

    /**
     * Module configuration method.
     */
    value: function config() {} /* Implement in subclass. */

    /**
     * Module initializer method.
     */

  }, {
    key: 'run',
    value: function run() {} /* Implement in subclass. */

    /**
     * Register this module instance in the angular module registry.
     */

  }, {
    key: 'register',
    value: function register(module) {
      var injectedConfig = module.configDependencies.slice(0);
      var injectedRun = module.runDependencies.slice(0);

      injectedConfig.push(module.config);
      injectedRun.push(module.run);

      angular.module(module.moduleName, module.dependencies).config(injectedConfig).run(injectedRun);
    }
  }]);

  return Module;
}();

Module.dependencies = [];
Module.configDependencies = [];
Module.runDependencies = [];
Module.moduleName = '';
Module.$type = 'module';
'use strict';

window.$ng = {
  Directive: Directive,
  Controller: Controller,
  Module: Module,
  Service: Service,
  Factory: Factory,

  /**
   * Register the given class in its corresponding module.
   * @method
   *
   * @param {Class} cls   An instance of injectable.
   */
  register: function register(cls) {
    var type = cls.$type;
    var noModule = !cls.module || !cls.module.trim();

    // If this is not a Module class and has no module defined,
    // raise an error.
    if (type !== 'module' && noModule) {
      var name = cls.name;

      throw new Error('Module not defined for ' + type + ' "' + name + '"');
    }

    cls.register(cls);
  },

  /**
   * Traverses the DOM and counts the number of watchers.
   */
  wcount: function wcount() {
    var root = angular.element(document.getElementsByTagName('body'));
    var watchers = [];
    var watchersWithoutDuplicates = [];

    var f = function f(element) {
      angular.forEach(['$scope', '$isolateScope'], function (scopeProperty) {
        if (element.data() && element.data().hasOwnProperty(scopeProperty)) {
          // Append all the element watchers to the watchers array.
          angular.forEach(element.data()[scopeProperty].$$watchers, function (watcher) {
            return watchers.push(watcher);
          });
        }
      });

      // Process the children elements.
      angular.forEach(element.children(), function (childElement) {
        return f(angular.element(childElement));
      });
    };

    f(root);

    // Remove duplicate watchers.
    angular.forEach(watchers, function (item) {
      // Only add watchers that are not already present in the array.
      if (watchersWithoutDuplicates.indexOf(item) < 0) {
        watchersWithoutDuplicates.push(item);
      }
    });

    console.log('Watchers count:', watchersWithoutDuplicates.length);
  }
};